knitr::opts_chunk$set(echo = TRUE, fig.align="center", results="hold", cache = TRUE, fig.dim=c(8,3))
library(ggfortify)
library(VGAM)
library(ROCR)
library(tidyverse)
library(ggplot2)
library(esquisse)
library(FactoMineR)
library(leaps)
library(MASS)
library(glmnet)
library(gridExtra)
library(bestglm)
library(plotly)
library(caret)
library(factoextra)
# function used to break lines in the pdf outputs
# https://stackoverflow.com/questions/24020617/textwrapping-long-string-in-knitr-output-rstudio
str_break = function(x, width = 80L) {
n = nchar(x)
if (n <= width) return(x)
n1 = seq(1L, n, by = width)
n2 = seq(width, n, by = width)
if (n %% width != 0) n2 = c(n2, n)
substring(x, n1, n2)
}
# Lecture jeu de données, mise sous forme de facteur et corrections
data = read.table("DataEnergy-Student.csv", header = TRUE, sep = ",")
data$Glazing.area.distr = as.factor(factor(data$Glazing.area.distr))
data$Energy.efficiency = as.factor(data$Energy.efficiency)
data$orientation = as.factor(data$orientation)
data$Overall.height = factor(data$Overall.height, ordered = TRUE)
data$Glazing.area[which(data$Glazing.area.distr == 0)] = 0
# Informations sur le jeu de données
s = summary(data[,c(6,5,8,9,10)])
colnames(s)[5] = "Energy.eff" ; s
# Séparation des variables quantitatives et qualitatives
quanti = c(1, 2, 3, 4, 7, 9) ; quali = c(5, 6, 8, 10) ; allvariables = 1:10
par(mfrow=c(1,2))
plot(2*data$Roof.area + data$Wall.area, data$Surface.area, pch='.',
main = "Relation entre les surfaces",
xlab = "2 * Surface de toit + Surface murée",
ylab = "Surface totale")
plot(1/(data$Surface.area), data$Relative.compactness, pch='.',
main = "Relation entre compacité et surface",
xlab = "Inverse de la surface totale",
ylab = "Compacité relative")
par(mfrow = c(2,2), mar = c(4,4,2,1))
plot(Energy ~ Relative.compactness, data = data, pch = '.')
plot(Energy ~ Surface.area, data = data, pch = '.')
plot(Energy ~ Wall.area, data = data, pch = '.')
boxplot(Energy ~ Overall.height, data = data, pch = '.')
layout(matrix(c(1,2,3,2), 2, 2, byrow = TRUE))
par(mar = c(4,4,2,1))
boxplot(Energy ~ orientation, data = data)
plot(Energy ~ Glazing.area, data = data)
boxplot(Energy ~ Glazing.area.distr, data = data)
par(mfrow=c(1,2))
res.acp <- PCA(data,scale.unit=T,quali.sup=quali,quanti.sup=9,ncp=8, graph=F)
barplot(res.acp$eig[,"percentage of variance"], main="Pourcentage de variance",
names.arg = seq(1,5), xlab = "Composantes principales")
barplot(res.acp$eig[,"cumulative percentage of variance"],
main="Pourcentage de variance cumulée",
names.arg = seq(1,5), xlab = "Composantes principales")
abline(h = 95, col = "red")
print(paste("Pourcentage d'inertie expliquée par les trois premiers axes :",
res.acp$eig[,"cumulative percentage of variance"][3]))
layout_matrix = matrix(c(1,2,3,3), 2, 2, byrow = TRUE)
gg1 = plot.PCA(res.acp, choix="var", axes = c(1,2), new.plot = F,title = "Variables (axes 1/2)")
gg2 = plot.PCA(res.acp, choix="var", axes = c(1,3), new.plot = F,title = "Variables (axes 1/3)")
gg3 = plot.PCA(res.acp, choix="var", axes = c(2,3), new.plot = F,title = "Variables (axes 2/3)")
grid.arrange(gg1,gg2,gg3,layout_matrix=layout_matrix)
gg1 = plot(res.acp,choix="ind",axes = c(1,2),invisible="quali",habillage="Energy.efficiency",
label="none", new.plot=F) + theme(text=element_text(size=8),legend.position="none")
gg2 = plot(res.acp, choix="ind", axes = c(2,3), invisible="quali",habillage="Energy.efficiency",
label="none", new.plot=F) + theme(text=element_text(size=8), legend.position="none")
gg3 = plot(res.acp, choix="ind",axes = c(1,3),invisible="quali",habillage="Energy.efficiency",
label="none", new.plot=F) + theme(text=element_text(size=8)) +
guides(color=guide_legend(ncol=2))
grid.arrange(gg1,gg2,gg3,layout_matrix = layout_matrix)
gg1 = plot(res.acp,choix="ind",axes = c(1,2),invisible="quali",habillage="Relative.compactness",
label = "none", new.plot = FALSE) + theme(text = element_text(size=8))
gg2 = plot(res.acp, choix="ind", axes = c(1,2), invisible="quali", habillage="Overall.height",
label = "none", new.plot = FALSE) + theme(text = element_text(size=8))
grid.arrange(gg1,gg2,ncol=2)
gg1 = ggplot(data) + aes(x = Relative.compactness, y = Energy) +
geom_point() + theme_minimal()
gg2 = ggplot(data) + aes(x = Glazing.area, y = Energy) +
geom_point() + theme_minimal()
grid.arrange(gg1,gg2,ncol=2)
par(mfrow=c(1,2), mar = c(4,4,2,1))
hc = hclust(dist(data[c(1,2,3,4,5,7)]), method = "ward.D2")
plot(hc, xlab = "")
abline(h=c(3400,1300,880,200),col="red")
plot(sort(hc$height, decreasing = TRUE)[1:20], ylab = "Variance inter-classe")
abline(v=c(1.5,3.5,4.5,11.5),col="red")
class2 = cutree(hc, k = 2)   # clustering hiérarchique à 2 classes
class4 = cutree(hc, k = 4)   # clustering hiérarchique à 4 classes
class12 = cutree(hc, k = 12) # clustering hiérarchique à 12 classes
gg1 = ggplot(data) + aes(x = Relative.compactness, y = Energy) +
geom_point(size = 1L, colour = class2) + theme_minimal()
gg2 = ggplot(data) + aes(x = Relative.compactness, y = Energy) +
geom_point(size = 1L, colour = class4) + theme_minimal()
gg3 = ggplot(data) + aes(x = Relative.compactness, y = Energy) +
geom_point(size = 1L, colour = class12) + theme_minimal()
grid.arrange(gg1,gg2,gg3,ncol=3)
ggplot(data) + aes(x = Wall.area, y = Energy) +
geom_point(size = 0.7, colour = class4) + theme_minimal()
table(class2, data$Overall.height)
set.seed(42)
kmres2 = kmeans(data[,c(1:5,7)], centers = 2) # k-means à 2 classes
table(kmres2$cluster, data$Overall.height)
set.seed(42)
kmres4 = kmeans(data[,c(1:5,7)], centers = 4) # k-means à 4 classes
kmclus4 = kmres4$cluster
kmres12 = kmeans(data[,c(1:5,7)], centers = 12) # k-means à 12 classes
kmclus12 = kmres12$cluster
gg1 = ggplot(data) + aes(x = Wall.area, y = Energy) +
geom_point(size = 0.5, aes(color = as.factor(kmclus4))) +
stat_ellipse(aes(group = as.factor(class4))) +
theme_minimal() + theme(legend.position = "none")
gg2 = ggplot(data) + aes(x = Relative.compactness, y = Energy) +
geom_point(size = 0.5, aes(color = as.factor(kmclus12))) +
stat_ellipse(aes(group = as.factor(class12))) +
theme_minimal() + theme(legend.position = "none")
grid.arrange(gg1,gg2,ncol=2)
data_classes = data ; data_classes$class2 = as.factor(class2)
data_classes$class4 = as.factor(class4) ; data_classes$class12 = as.factor(class12)
res.acp_classes=PCA(data_classes,scale.unit=T,quali.sup=c(quali,11,12,13),quanti.sup=9,graph=F)
gg1 = fviz_pca_ind(res.acp_classes, c(1,2), habillage="class12", labels = F)
gg2 = fviz_pca_ind(res.acp_classes, c(1,3), habillage="class12", labels = F)
grid.arrange(gg1+theme(legend.position="none"),gg2+theme(legend.position="none"),ncol=2)
model_quanti_complet = lm(Energy ~ (. - Roof.area)^2, data = data[,quanti])
paste("R² =",summary(model_quanti_complet)$r.squared)
data$fitted_quanti_complet = model_quanti_complet$fitted.values
ggplot(data) +
aes(x = fitted_quanti_complet, y = Energy) +
geom_point() + geom_abline(slope = 1) +
labs(title = "Regression linéaire de `Energy` en fonction des variables quantitatives",
x = "Valeurs ajustées") +
theme_minimal()
modselect_quanti_bic_back = stepAIC(model_quanti_complet,trace=FALSE,
direction=c("backward"),k=log(nrow(data)))
f = paste("Energy ~", paste(dimnames(modselect_quanti_bic_back$qr$qr)[[2]][-1], collapse=" + "))
str_break(f)  # pour autoriser des retours à la ligne dans la sortie
anova(modselect_quanti_bic_back, model_quanti_complet)
paste("R² =", summary(modselect_quanti_bic_back)$r.squared)
# centrage et reduction des données
energy = scale(data["Energy"],center=T,scale=T)
expli = scale(data[quanti[-6]],center=T,scale=T)
# création du tableau de tau
tau_seq <- seq(0, 0.1, by = 0.0001)
fitlasso <- glmnet(x = expli, y = energy, family = "gaussian", alpha = 1,
lambda = tau_seq, intercept = F)
dflasso=data.frame(tau = rep(fitlasso$lambda,ncol(expli)), theta=as.vector(t(fitlasso$beta)),
variable=rep(colnames(expli), each=length(fitlasso$lambda)))
ggplot(dflasso,aes(x=tau,y=theta,col=variable)) +
geom_line() +
geom_vline(xintercept = 0.02, linetype = "dotted", color = "red") +
theme(legend.position="right")
model_complet = lm(Energy ~ (. - Roof.area)^2, data = data[,allvariables[-10]])
data$fitted_complet = model_complet$fitted.values
model_no_interactions = lm(Energy ~ . - Roof.area, data = data[,allvariables[-10]])
anova(model_complet, model_no_interactions)
modselect_bic_back=stepAIC(model_complet,trace=FALSE,direction=c("backward"),k=log(nrow(data)))
f = paste("Energy ~", paste(dimnames(modselect_bic_back$qr$qr)[[2]][-1], collapse=" + "))
str_break(f)
anova(modselect_bic_back, model_complet)
par(mfrow=c(1,2)) ; plot(modselect_bic_back, which=c(1,2), pch="+", cex=0.6)
set.seed(42)
train.control = trainControl(method = "cv", number = 10, p = 0.8)
model_cv = train(modselect_bic_back$terms, data = data, method = "lm", trControl = train.control)
print(model_cv)
# Modéle linéaire généralisée
# Définition de Energy.efficiencyBIs
new_data <- data[,c(-11,-12,-13,-14,-15)]
data.mlg = data.frame(new_data, Energy.efficiency.bis = rep(0, nrow(new_data)))
data.mlg$Energy.efficiency.bis[which(data.mlg$Energy.efficiency == "A" | data.mlg$Energy.efficiency == "B")] = "1"
data.mlg$Energy.efficiency.bis[which(data.mlg$Energy.efficiency !="A" & data.mlg$Energy.efficiency !="B" )] = "0"
data.mlg$Energy.efficiency.bis = as.factor(data.mlg$Energy.efficiency.bis)
data.mlg<-data.mlg[,c(-4,-9,-10)]
#Statistique Descriptive
boxplot(Relative.compactness~ Energy.efficiency.bis,data=data.mlg)
boxplot(Surface.area~ Energy.efficiency.bis,data=data.mlg)
boxplot(Wall.area~ Energy.efficiency.bis,data=data.mlg)
boxplot(Overall.height~ Energy.efficiency.bis,data=data.mlg)
boxplot(Glazing.area~ Energy.efficiency.bis,data=data.mlg)
mosaicplot(table(data.mlg[,c("Energy.efficiency.bis","orientation")]))
# Ajustement du modèle linéaire généralisé additif
mlg_rg <- glm(Energy.efficiency.bis~.,data=data.mlg,family=binomial(link=logit))
summary(mlg_rg)
#Calcul de pseudo R2 de mlg_rg
pseudoR2 = 1 - ( mlg_rg$deviance/mlg_rg$null.deviance)
print("Pseudo R2 ")
print(pseudoR2)
print("############################  AIC  #############################")
mlg.BIC <- bestglm(data.mlg, family = binomial, IC = "BIC")
mlg.BIC$BestModel
print('')
print("############################  BIC  #############################")
mlg.AIC <- bestglm(data.mlg, family = binomial, IC = "AIC")
mlg.AIC$BestModel
#
mlg_rg_best_aic <- glm(Energy.efficiency.bis~Relative.compactness + Overall.height+Glazing.area,family=binomial(link=logit),data=data.mlg)
anova(mlg_rg_best_aic,mlg_rg,test="Chisq")
# On note que le sous modèle bic est un sous modèle du modèle AIC
#### Comparaison du modèle AIC  avec le sous modèle BIC
mlg_rg_best_bic <- glm(Energy.efficiency.bis~Relative.compactness + Glazing.area +
Overall.height + Glazing.area.distr,family=binomial(link=logit),data=data.mlg)
summary(mlg_rg_best_bic)
anova(mlg_rg_best_bic,mlg_rg,test="Chisq")
#Ajustement du modèle complet avec intéraction
mlg_rg_inter <- glm(Energy.efficiency.bis~Relative.compactness +
Surface.area + Wall.area + Overall.height + orientation +
Glazing.area + Glazing.area.distr + Surface.area:Relative.compactness+Wall.area:Glazing.area +Surface.area:Wall.area,data=data.mlg,family=binomial(link="logit"))
summary(mlg_rg_inter)
#Calcul de pseudo R2
pseudoR2 = 1 - ( mlg_rg_inter$deviance/mlg_rg_inter$null.deviance)
print("Pseudo R2 ")
print(pseudoR2)
modelbestinter = step(mlg_rg_inter,trace = FALSE)
summary(modelbestinter)
mlg_inter_best_aic <- glm(Energy.efficiency.bis ~ Relative.compactness + Surface.area +
Wall.area + Overall.height + orientation + Glazing.area +
Glazing.area.distr + Surface.area:Wall.area,family=binomial(link=logit),data=data.mlg)
summary(mlg_inter_best_aic)
anova(mlg_inter_best_aic,mlg_rg_inter,test="Chisq")
anova(mlg_rg_best_aic,mlg_inter_best_aic,test="Chisq")
data.mlg.p<-new_data[,c(-4,-9)]
#Statistique Descriptive
boxplot(Relative.compactness~ Energy.efficiency,data=data.mlg.p)
boxplot(Surface.area~ Energy.efficiency,data=data.mlg.p)
boxplot(Wall.area~ Energy.efficiency,data=data.mlg.p)
boxplot(Overall.height~ Energy.efficiency,data=data.mlg.p)
boxplot(Glazing.area~ Energy.efficiency,data=data.mlg.p)
mosaicplot(table(data.mlg.p[,c("Energy.efficiency","orientation")]))
# transformation en variable ordinale
data.mlg.p$Energy.efficiency = factor(data.mlg.p$Energy.efficiency, order = TRUE, levels = c("A", "B",
"C", "D","E","F","G"))
modelord <- vglm(Energy.efficiency ~ Relative.compactness, data = data.mlg.p, family = acat())
prct_bien_classe=function(table){
a =(table[1]+table[4])/sum(table)
return(a)
}
data.nlm.class = data.mlg
ratio_train = 0.75
# On sépare les données en un ensemble d'apprentissage et un ensemble de test
nb_train <- floor(ratio_train * nrow(data.nlm.class))
train_ind <- sample(seq_len(nrow(data.nlm.class)), size = nb_train)
train.dis <- data.nlm.class[train_ind, ]
test.dis <- data.nlm.class[-train_ind, ]
hatY = (mlg_rg$fitted.values > 0.5)
# Table de contingences pour la régression logistique
t_reg_log = table(data.mlg[-train_ind,]$Energy.efficiency.bis, hatY[-train_ind])
t_reg_log
# Pourcentage de valeurs correctement prédites
pct_reg_log = prct_bien_classe(t_reg_log)
pct_reg_log
library(rpart) # chargement de la librairie
library(rpart.plot)
tree.dis=rpart(Energy.efficiency.bis~.,data=train.dis, parms = list(split = "information"),cp=0.001)
rpart.plot(tree.dis)
pred.tree <- predict(tree.dis,newdata=test.dis,type="class")
# Table de contingences pour l'arbre binaire de décision naïf
t_class_dis = table(pred.tree, test.dis[, "Energy.efficiency.bis"])
t_class_dis
# Pourcentage de valeurs correctement prédites
pct_class_dis = prct_bien_classe(t_class_dis)
pct_class_dis
# Optimisation de cp
xmat <- xpred.rpart(tree.dis)
# Comparaison des valeurs prédite et observée
xerr <- (train.dis$Energy.efficiency.bis != 0) != (xmat > 1.5)
# Calcul  des estimations des taux d'erreur
CVerr <- apply(xerr, 2, sum)/nrow(xerr)
cpMin <- as.numeric(attributes(which.min(CVerr))$names)
tree.dis.opti <- rpart(Energy.efficiency.bis~., data = train.dis, parms = list(split = "information"), cp = cpMin)
rpart.plot(tree.dis.opti)
pred.tree.opti <- predict(tree.dis,newdata=test.dis,type="class")
# Table de contingences pour l'arbre binaire de décision optimal
t_class_dis = table(pred.tree.opti, test.dis[, "Energy.efficiency.bis"])
t_class_dis
# Pourcentage de valeurs correctement prédites
pct_class_dis = prct_bien_classe(t_class_dis)
pct_class_dis
library(randomForest)
rf.dis <- randomForest(Energy.efficiency.bis ~ ., data = train.dis[,c(-4,-7)],
xtest = test.dis[, c(-4,-7,-8)], ytest = test.dis[, "Energy.efficiency.bis"],
ntree = 500, do.trace = 50, importance = TRUE)
pred.rf <- rf.dis$test$predicted
# Table de contingences pour la random forest naïve
t_rdm_forest = table(pred.rf, test.dis[,"Energy.efficiency.bis"])
t_rdm_forest
# Pourcentage de valeurs correctement prédites
pct_rdm_forest = prct_bien_classe(t_rdm_forest)
pct_rdm_forest
# Optimisation de mtry
library(caret)
cvControl <- trainControl(method = "cv", number = 10)
rfFit <- train(train.dis[, -8], train.dis[, 8], method = "rf", tuneLength = 8,
trControl = cvControl, trace = FALSE)
rf.dis.opti <- randomForest(Energy.efficiency.bis ~ ., data = train.dis[,c(-4,-7)],
xtest = test.dis[, c(-4,-7,-8)], ytest = test.dis[, "Energy.efficiency.bis"],
ntree = 500, do.trace = 50, importance = TRUE,mtry=as.integer(rfFit$bestTune))
pred.rf.opti <- rf.dis.opti$test$predicted
# Table de contingences pour la random forest naïve
t_rdm_forest_opti = table(pred.rf.opti, test.dis[,"Energy.efficiency.bis"])
t_rdm_forest_opti
# Pourcentage de valeurs correctement prédites
pct_rdm_forest_opti = prct_bien_classe(t_rdm_forest_opti)
pct_rdm_forest_opti
data.nlm.reg = new_data[,c(-4,-10)]
# On sépare les données en un ensemble d'apprentissage et un ensemble de test
nb_train <- floor(ratio_train * nrow(data.nlm.reg))
train_ind <- sample(seq_len(nrow(data.nlm.reg)), size = nb_train)
train.reg <- data.nlm.reg[train_ind, ]
test.reg <- data.nlm.reg[-train_ind, ]
library(rpart) # chargement de la librairie
library(rpart.plot)
tree.reg=rpart(Energy ~.,data=train.reg, cp=0.001)
rpart.plot(tree.reg)
pred.tree <- predict(tree.reg,newdata=test.reg)
# Table de contingences pour l'arbre binaire de décision naïf
t_class_reg = table(pred.tree > 35, test.reg[, "Energy"] > 35)
t_class_reg
# Pourcentage de valeurs correctement prédites
pct_class_reg = prct_bien_classe(t_class_reg)
pct_class_reg
xmat <- xpred.rpart(tree.reg)
xerr <- (xmat-train.reg[,"Energy"])^2
CVerr <- apply(xerr, 2, sum)
# On cherche la valeur de cp qui minimise l'erreur
cpMin <- as.numeric(attributes(which.min(CVerr))$names)
tree.reg <- rpart(Energy~., data = train.reg, control = rpart.control(cp = cpMin))
pred.treer <- predict(tree.reg,newdata=test.reg)
# Table de contingences pour l'arbre binaire de décision naïf
t_reg = table(pred.treer > 35, test.reg[, "Energy"] > 35)
t_reg
# Pourcentage de valeurs correctement prédites
pct_reg = prct_bien_classe(t_reg)
pct_reg
mlg_inter_best <- glm(Energy.efficiency.bis ~ Relative.compactness + Surface.area +
Wall.area + Overall.height + orientation + Glazing.area +
Glazing.area.distr + Surface.area:Wall.area,family=binomial(link=logit),data=data.mlg)
summary(mlg_inter_best)
anova(mlg_inter_best_bic,mlg_rg_inter,test="Chisq")
mlg_inter_best <- glm(Energy.efficiency.bis ~ Relative.compactness + Surface.area +
Wall.area + Overall.height + orientation + Glazing.area +
Glazing.area.distr + Surface.area:Wall.area,family=binomial(link=logit),data=data.mlg)
summary(mlg_inter_best)
anova(mlg_inter_best,mlg_rg_inter,test="Chisq")
mlg_inter_best <- glm(Energy.efficiency.bis ~ Relative.compactness + Surface.area +
Wall.area + Overall.height + orientation + Glazing.area +
Glazing.area.distr + Surface.area:Wall.area,family=binomial(link=logit),data=data.mlg)
summary(mlg_inter_best)
anova(mlg_inter_best,mlg_rg_inter,test="Chisq")
anova(mlg_rg_best_aic,mlg_inter_best,test="Chisq")
anova(mlg_rg_best,mlg_inter_best,test="Chisq")
anova(mlg_rg_best_bic,mlg_inter_best,test="Chisq")
modelord <- vglm(Energy.efficiency ~ Relative.compactness+ Glazing.area +
Overall.height + Glazing.area.distr, data = data.mlg.p, family = acat())
modelord <- vglm(Energy.efficiency ~ Relative.compactness+ Glazing.area  + Glazing.area.distr, data = data.mlg.p, family = acat())
