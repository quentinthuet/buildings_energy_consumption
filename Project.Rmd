---
title: "Projet Stats"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.align="center", results="hold")
library(ggplot2)
library(esquisse)
```

## R Markdown

```{r}
# Lecture jeu de données
data = read.table("DataEnergy-Students.csv", header = TRUE, sep = ",")
data
# Mise sous forme de facteur des données catégorielles
data$Energy.efficiency = as.factor(data$Energy.efficiency)
data$Glazing.area.distr = as.factor(data$Glazing.area.distr)
data$orientation = as.factor(data$orientation)
# Correction du jeu de données
data$Glazing.area[which(data$Glazing.area.distr == 0)] = 0
# Infos sur le jeu de données
str(data)
```
Le jeu de données est composé de 768 batiments avec chacun 10 variables.

Quantitatives :
- Relative.compactness : compacité relative à un cube de même volume (FORMULE)
- Surface.area : surface totale (sol + murs + toit)
- Wall.area : surface de mur extérieurs
- Roof.area : surface de toit
- Overall.height : hauteur du batiment (soit 3.5 soit 7 m)
- Glazing.area : Surface vitrée (en pourcentage de la surface au sol)
- Load : Energie consommée (sortie du problème)
Catégorielles :
- orientation : orientation de la maison (Nord, Sud, Est, Ouest)
- Glazing.area.distr : Distribution des vitres (Uniforme, ou plus d'un coté)
- Energy.efficiency : Indicateur de l'énergie consommées (de A à G)

```{r}
quanti <- c(1:5, 7, 9)
quali <- c(6, 8, 10) 
pairs(data[, quanti], pch = '.', cex = 0.1, cex.labels = 0.55) 
plot(2*data$Roof.area + data$Wall.area, data$Surface.area)
```


```{r}
summary(data)
```

Même nombre de batiments faisant face à chaque orientation. Même nombre de batiments avec les différentes répartitions de fenêtres, sauf les batiments sans fenêtres.

```{r}
ggplot(data) +
 aes(x = Glazing.area, y = Load, colour = as.factor(Overall.height)) +
 geom_point(size = 1L) +
 theme_minimal() + geom_smooth(method = "lm")
```

On voit que la surface vitrée à une influence sur l'énergie consommée.

```{r}
boxplot(Load ~ Overall.height, data = data)
```


```{r}
ggplot(data) +
 aes(x = Relative.compactness, y = Load) +
 geom_point(size = 1L, colour = "#0c4c8a") +
 theme_minimal()
```

On voit qu'il semble y avoir 12 groupes de points assez distincts.
Nous allons essayer de mettre en évidence ces 12 groupes en réalisant un clustering par la méthode des k-means.

```{r}
hc = hclust(dist(data[c(1,2,3,4,5,7)]), method = "ward.D2")
plot(hc)
plot(sort(hc$height, decreasing = TRUE)[1:20])
```

```{r}
class2 = cutree(hc, k = 2)
ggplot(data) +
 aes(x = Surface.area, y = Load) +
 geom_point(size = 1L, colour = class2) +
 theme_minimal()
class4 = cutree(hc, k = 4)
ggplot(data) +
 aes(x = Surface.area, y = Load) +
 geom_point(size = 1L, colour = class4) +
 theme_minimal()
class12 = cutree(hc, k = 12)
ggplot(data) +
 aes(x = Surface.area, y = Load) +
 geom_point(size = 1L, colour = class12) +
 theme_minimal()
```

```{r}
library("FactoMineR")
data$class2 = as.factor(class2)
data$class4 = as.factor(class4)
data$class12 = as.factor(class12)
res.acp <- PCA(data,scale.unit=T,quali.sup=c(6,8,10,11,12,13),quanti.sup=9,ncp=8, graph=F)
barplot(res.acp$eig[,"percentage of variance"], main="Pourcentage d'inertie")
barplot(res.acp$eig[,"cumulative percentage of variance"], main="Pourcentage d'inertie cumulé")
sum(res.acp$eig[,"percentage of variance"][1:3])
plot(res.acp, choix="var", axes = c(1,2))
plot(res.acp, choix="var", axes = c(2,3))
plot(res.acp, choix="var", axes = c(1,3))
```

```{r}
plot(res.acp, choix="ind", axes = c(1,2), invisible="quali", habillage="Energy.efficiency")
plot(res.acp, choix="ind", axes = c(2,3), invisible="quali", habillage="Energy.efficiency")
plot(res.acp, choix="ind", axes = c(1,3), invisible="quali", habillage="Energy.efficiency")
```

Première composante principale : Hauteur, compacité (en positif) et surface totale, surface de toit (en négatif)
Deuxième composante principale : Surface de murs
Troisème composante principale : Surface vitrée

```{r}
kmres = kmeans(data[,c(1:5,7)], centers = 7)
pairs(data[,quanti], col = kmres$cluster)
```

